# Основные команды git

## Полезные ссылки:
- [Статья про параметр core.autocrlf](https://habr.com/ru/articles/703072/)
- [Разница между switch и checkout](https://stackoverflow.com/questions/57265785/whats-the-difference-between-git-switch-and-git-checkout-branch)


---

## help - справка по командам.
Чтобы открыть информацию по команде нужно ввести команду:
```shell
git <command> --help
```
К примеру `git commit --help`. Мануал откроется в браузере по умолчанию.


## init - инициализация репозитория.
Инициализация репозитория в текущей папке, или другими словами - сделать текущую папку репозиторием.
```shell
git init
```
Если необходимо дать имя репозиторию, то нужно ввести такую команду: `git init basic-git`, где `basic-git` - имя репозитория.


## clone - клонирование репозитория.
Для клонирования удаленного репозитория нужно выполнить команду:
```shell
git clone <remote-url>
```
Пример команды: `git clone https://github.com/LpilinAlexandr/basic-git.git`


## config - настройки.
```shell
git config -l # Список текущих настроек
git config --global -l  # Список глобальных настроек
git config --local -l  # Список локальных настроек репозитория

git config --global user.name "Name"  # Установить имя пользователя в глобальной области
git config --global user.email "email@example.com" # Установить email пользователя в глобальной области

git config --unset <var> # Удалить переменную из настроек

git config alias.<your-alias> <command>  # Создание алиаса для команды
git config alias.st status  # Пример: теперь сможем писать git st вместо git status

git config --global core.autocrlf <input|false|true>  # Настройка параметра окончания строки.
```


## status - статус файлов и директорий в репозитории.
Чтобы узнать статус каждого файла и директории в репозитории нужно воспользоваться командой:
```shell
git status
git status -s  # Статус в короткой форме
```
Будет выведена информация о том: какой файл был изменен, какой не отслеживается, какой добавлен и т.д.


## log - логи репозитория.
```shell
git log  # Посмотреть логи по порядку
git log <branch-name>  # Посмотреть логи по конкретной ветке
git log --grep <pattern>  # Поиск коммитов с подходящей подстрокой
git log --invert-grep <pattern>  # Поиск коммитов, не входящих в подстроку
git log --oneline  # Список логов, каждый в одной строке
```


## add | restore | rm - управление файлами и директориями.
```shell
git add <path>  # Добавить в индекс всю директорию или файл по указанному пути
git add .  # Добавить всё в текущей директории
git restore --staged <path>  # Исключает из индекса добавленную директорию или файл по указанному пути
git restore <path>  # Отменить изменения в указанном месте 
git rm  # Фактически то же самое, что и удаление файла/директории
```


## remote - управление удаленными адресами.
Если репозиторий был инициализирован, а не клонирован, то у репозитория не будет адреса, того самого адреса. который указывает, куда сливать код при "пуше" команда `git push` или откуда стягивать код при команде "пулл" `git pull`. Чтобы добавить в локальный репозиторий адресс удаленного репозитория нужно выполнить команду:
```shell
git remote add origin <remote-url>
```
Полная команда выглядит так: `git remote add origin https://github.com/LpilinAlexandr/basic-git123.git`

Чтобы изменить remote адрес нужно выполнить команду:
```shell
git remote set-url origin <remote-url> 
```
Полная команда выглядит так: `git remote set-url origin https://github.com/LpilinAlexandr/basic-git123.git`  

Чтобы посмотреть список всех remote адресов есть команда:
```shell
git remote -v
```


## stash - добавить изменения в стэш (почти стэк).
Если мы отстрелились от ветки `main` и работаем в ветке `feature`, и вдруг нам понадобилось вернуться в ветку `main`, то придется сделать бесполезный коммит, иначе гит не даст нам переключится между ветками. Чтобы не делать бесполезные коммиты, мы можем в нашей ветке `feature` добавить все изменения в стэш и спокойно переключится на другую ветку, после переключения обратно можно достать последние изменения из стэша.
```shell
git stash -m 'my stash name'  # Спрячет все изменения в стеш 
git stash pop  # Достанет последние изменения из стеша, удалив его оттуда. По дефолту 0
git stash apply  # Достанет последние изменения из стеша, сохранив его. По дефолту 0
git stash list  # Посмотреть список всех стешей
git stash show <stash>  # Посмотреть стеш. По дефолту 0
git stash drop <stash>  # Удалить стеш. По дефолту 0
```


## branch - управление ветками.
```shell
git branch  # Посмотреть список локальных веток
git branch <branch-name> # Создать новую ветку от текущей ветки
git branch -a  # Посмотреть полный список веток вместе с remotes
git branch -m  # Переименовать ветку
git branch -d / -D  # Удалить ветку. Мягкое и жесткое удаление
```


## commit - сохранить изменения.
```shell
git commit -m 'Заголовок коммита'  # Сделать коммит
git commit -m 'Заголовок коммита' -m 'Текст под заголовком коммита'  # Сделать коммит с заголовком и доп. текстом

git commit <path> -m 'Заголовок'  # Закоммитить выбранный каталог

git commit --amend [-m] # Закоммитить изменения в предыдущий коммит
git commit --amend  --no-edit # Закоммитить изменения в предыдущий коммит без редактирования заголовка и описания
```


## push
```shell
git push <remote> <branch>  # Отправить локальную ветку на remote 
git push -f <remote> <branch>  # Отправить принудительно локальную ветку на remote, перезаписав её 
git push -u <remote> <branch>  # Отправляем локальную ветку на remote и устанавливаем отслеживание
```


## switch | checkout
```shell
git checkout <branch> | <commit>  # Переключиться на ветку или коммит по его хешу
git checkout -b <new_branch>  # Отбранчеваться от текущей ветки в новую ветку и сразу переключиться на нее со всеми изменениями

git switch <branch> | <commit> # Переключиться на ветку или коммит по его хешу
git switch -c <new_branch>  # Отбранчеваться от текущей ветки в новую ветку и сразу переключиться на нее со всеми изменениями
``` 


## merge
```shell
git merge <branch>  # Слить изменения из ветки <branch> в текущую ветку
git merge --continue  # Продолжить слияние в случае решения конфликтов
git merge --abort  # Отменить merge
```
Наличие нескольких веток чрезвычайно удобно для того, чтобы новые изменения были отделены друг от друга, а также чтобы вы случайно не запушили несанкционированные или поврежденные изменения в продакшин. Как только изменения будут одобрены, мы хотим получить эти изменения в нашей прод ветке!

Один из способов получить изменения из одной ветки в другую - выполнить git merge! Есть два типа менж команд, которые может выполнять Git: fast-forward или no-fast-forward 

### Fast-forward (--ff)

Fast-forward merge когда текущая ветка не имеет дополнительных коммитов по сравнению с веткой, которую мы мержим. Git у нас ленив и сначала попытается выполнить самый простой вариант: Fast-forward! Этот тип менжа не создает новый коммит, а скорее объединяет коммит(ы) в ветку, которую мы объединяем прямо в текущей ветке

<img src="/img/merge_ff.gif" alt="" style="max-width: 100%;">

Отлично! Теперь у нас есть все изменения, которые были сделаны в ветке dev, в ветке master. Итак, что же такое  no-fast-forward?

### No-fast-foward (--no-ff)

Хорошо, если ваша текущая ветка не имеет каких-либо дополнительных коммитов по сравнению с веткой, которую вы хотите смержить, но, к сожалению, это случается редко! Если мы зафиксировали изменения в текущей ветке, которых нет в ветке, которую мы хотим объединить, git выполнит объединение без fast-forward merge. При слиянии без fast-forward Git создает новый коммит мержа в активную ветку. Родительский коммит указывает на активную ветку и ветку, которую мы хотим объединить!

<img src="/img/merge_noff.gif" alt="" style="max-width: 100%;">

### Merge конфликты

Хотя Git хорошо решает, как объединять ветки и добавлять изменения в файлы, он не всегда может принять это решение сам по себе. Это может произойти, когда две ветки, которые мы пытаемся смержить, имеют изменения в одной строке в одном и том же файле, или если одна ветка удалила файл, который изменила другая ветка, и так далее.

В этом случае Git попросит вас помочь решить, какой из двух вариантов мы хотим сохранить. Допустим, что в обеих ветках мы отредактировали первую строку в файле README.md.

<img src="/img/mc.png" alt="" style="max-width: 100%;">

Если мы хотим смержить dev в master, это приведет к конфликту: хотите, чтобы заголовок был Hello! или hey!?

При попытке объединить ветки, Git покажет вам, где происходит конфликт. Мы можем вручную удалить изменения, которые не хотим сохранять, сохранить изменения, снова добавить файл и закоммитить изменения.

<img src="/img/conflict.gif" alt="" style="max-width: 100%;">

## rebase
```shell
git rebase <commit>  # Встать коммитами текущей ветки на выбранный коммит 
git rebase <branch>  # Встать коммитами текущей ветки на выбранную ветку
git rebase --continue  # Продолжить слияние в случае решения конфликтов
git rebase --abort  # Отменить rebase
```

Мы только что увидели, как можно применить изменения из одной ветки в другую, выполнив git merge. Другой способ добавить изменения из одной ветки в другую - выполнить git rebase.

Git rebase копирует коммиты из текущей ветки и помещает эти скопированные коммиты поверх указанной ветки.

<img src="/img/rebase.gif" alt="" style="max-width: 100%;">

Отлично, теперь у нас есть все изменения, которые были сделаны в master ветке и в dev ветке. 🎊

Большая разница по сравнению с мержем заключается в том, что Git не будет пытаться выяснить, какие файлы сохранить и не сохранить. В ветке, которую мы обновляем, всегда есть последние изменения, которые мы хотим сохранить! Таким образом, вы не столкнетесь ни с какими мерж конфликтами и у вас будет хорошая линейная история.

Этот пример показывает rebase в master ветке. Однако в больших проектах вы обычно не захотите этого делать. Git rebase изменяет историю проекта, поскольку для скопированных коммитов создаются новые хэши.

Rebase отлично подходит, когда вы работаете над feature branch, а master ветка была обновлена. Вы можете получить все обновления в своей ветке, которые предотвратят будущие merge конфликты

### Interactive Rebase

Перед rebas'ом коммитов мы можем их изменить! 😃 Мы можем сделать это с помощью Interactive Rebase. Interactive Rebase также может быть полезен для ветки, над которой вы сейчас работаете, и хотите изменить некоторые коммиты.

Есть 6 действий, которые мы можем выполнить над коммитами, которые мы rebas'им:

- reword: Изменить коммит меседж
- edit: Изменить коммит
- squash: Объеденить коммит в предыдущий коммит
- fixup: Объединить коммит с предыдущим коммитом, не сохраняя commit's log message
- exec: Запустить команду для каждого коммита, который мы хотим rebase
- drop: Удалить коммит

Таким образом, мы можем иметь полный контроль над нашими коммитами. Если мы хотим удалить коммит, мы можем просто drop'нуть его.

<img src="/img/interactive.gif" alt="" style="max-width: 100%;">

Или, если мы хотим объединить несколько коммитов вместе, чтобы получить более чистую историю, нет проблем!

<img src="/img/comb.gif" alt="" style="max-width: 100%;">

Interactive rebasing дает вам большой контроль над коммитами, которые вы пытаетесь rebase'нуть, даже в текущей активной ветке.


## reset
```shell
git reset <commit>  # Сбросить коммиты в индекс до указанного коммита
--soft  # Изменения сбрасываются в индекс (Дефолтное значение)
--hard  # Изменения удаляются
git reset --soft HEAD~  # Сбросить последний коммит в индекс
git reset --hard HEAD~4  # Убить последние 4 коммита

# squash life-hack
git reset --soft HEAD~3  # Сбрасываем 3 последних коммита в 1
git commit -m 'Обьединили 3 коммита'  # Коммитим заново, тем самым объединяя 3 коммита в 1
```

Может случиться так, что мы допустили изменения, которые мы не хотели заливать. Может быть, это коммит еще в работе или коммит, в котором есть ошибки! В этом случае мы можем выполнить git reset.

git reset избавляет от всех текущих промежуточных файлов и дает нам контроль над тем, куда должен указывать HEAD.

### Soft reset

Soft reset перемещает HEAD к указанному коммиту (или индексу коммита по сравнению с HEAD), не избавляясь от изменений, которые были внесены в коммиты позже.

Допустим, мы не хотим сохранять коммит 9e78i, в который был добавлен файл style.css, и мы также не хотим сохранять коммит 035cc, в который был добавлен файл index.js. Однако мы хотим сохранить недавно добавленные файлы style.css и index.js. Идеальный кейс для sort reset.

<img src="/img/sr.gif" alt="" style="max-width: 100%;">

Набрав git status, вы увидите, что у нас все еще есть доступ ко всем изменениям, которые были сделаны во время предыдущих коммитов. Это здорово, так как это означает, что мы можем исправить содержимое этих файлов и закоммитить их позже.

### Hard reset

Иногда мы не хотим сохранять изменения, внесенные некоторыми коммитами. В отличие от soft reset, нам не нужно больше иметь к ним доступ. Git должен просто сбросить свое состояние обратно туда, где он был в указанном коммите: это даже включает изменения в вашей working directory и stage файлах!

<img src="/img/hard.gif" alt="" style="max-width: 100%;">

Git отменил изменения, которые были внесены в 9e78i и 035cc, и сбросил свое состояние до того, где он был при коммите ec5be.


## revert
```shell
git revert <commit>  # Отменить коммит
git revert -n <commit>  # Отменить коммит и оставить изменения в индексе
```

Другой способ отменить изменения - выполнить git revert. Отменяя определенный коммит, мы создаем новый коммит, который содержит отмененные изменения.

Допустим, ec5be добавил файл index.js. Позже мы на самом деле понимаем, что больше не хотим, чтобы это изменения были в ветке! Давайте ревертнем коммит ec5be.


## cherry-pick
```shell
git cherry-pick <commit>  # Перенести коммит в HEAD текущей ветки
git cherry-pick -n <commit>  # Перенести коммит в HEAD текущей ветки, но не делать коммит
```

Когда определенная ветка содержит коммит, который внес изменения, которые нам нужны в нашей активной ветке, мы можем черипинуть коммит в нашу ветку. Cherry-pick создает новый коммит в нашей активной ветке, который содержит изменения, которые были в чери-пикнутом коммите.

Предположим, что коммит 76d12 в ветке dev добавил изменение в файл index.js, которое мы хотим добавить в master:

<img src="/img/cp.gif" alt="" style="max-width: 100%;">


## fetch
```shell
git fetch # Запросить все изменения из origin 
git fetch <remote> # Запросить все изменения из remote
git fetch <remote> --prune # Запросить все изменения из remote и синхронизировать их
```

Если у нас есть remote Git ветка, например ветка на Github, может случиться так, что remote ветка имеет коммиты, которых нет у текущей ветки! Возможно, другая ветка была объединена, или ваш коллега добавил hot fix и так далее.

Мы можем получить эти изменения локально, выполнив git fetch на remote ветке. Это никак не влияет на вашу локальную ветку: fetch просто загружает новые данные.

<img src="/img/fetch.gif" alt="" style="max-width: 100%;">


## pull
```shell
git pull origin <branch>  # Стянуть из remote актуальную ветку <branch> (По умолчанию режим merge)
git pull origin <branch> --rebase  # Стянуть из remote актуальную ветку в режиме rebase
```

Хотя git fetch очень полезен для получения remote информации о ветке, мы также можем выполнить git pull. Git pull - это две команды в одной: git fetch и git merge. Когда мы извлекаем изменения из origin, мы сначала fetch'им все данные, как мы делали с помощью git fetch, после чего последние изменения автоматически мержатся в локальную ветку.

<img src="/img/pull.gif" alt="" style="max-width: 100%;">


## reflog
```shell
git reflog  # Показать историю
git reflog <branch> # Показать историю по конкретной ветке
```

Все делают ошибки, и это совершенно нормально! Иногда может показаться, что вы испортили свой репозиторий Git настолько сильно, что просто хотите полностью его удалить.

git reflog - очень полезная команда для отображения журнала всех выполненных действий! Это включает в себя слияния, перезагрузки, возвраты: в основном, любые изменения в вашей ветке.

<img src="/img/reflog.gif" alt="" style="max-width: 100%;">

Если вы допустили ошибку, вы можете легко отменить ее, сбросив HEAD на основе информации, которую нам предоставляет reflog.

Скажем, мы на самом деле не хотели мержить origin ветку. Когда мы выполняем команду git reflog, мы видим, что состояние репозитория до мержа- HEAD@{1}. Давайте выполним git reset, чтобы указать HEAD туда, где он был.

<img src="/img/resh.gif" alt="" style="max-width: 100%;">

Как мы видим, последнее действие было перенесено в рефлог.
